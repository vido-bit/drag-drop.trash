{"version":3,"sources":["../src/memoize.js","../src/index.ts"],"sourcesContent":["//\n// Code from `fast-memoize`\n//\n\nfunction memoize(fn, options) {\n\tvar cache = options?.cache ?? cacheDefault;\n\tvar serializer = options?.serializer ?? serializerDefault;\n\tvar strategy = options?.strategy ?? strategyDefault;\n\n\treturn strategy(fn, {\n\t\tcache: cache,\n\t\tserializer: serializer,\n\t});\n}\n\n//\n// Strategy\n//\n\nfunction isPrimitive(value) {\n\treturn value == null || typeof value === 'number' || typeof value === 'boolean'; // || typeof value === \"string\" 'unsafe' primitive for our needs\n}\n\nfunction monadic(fn, cache, serializer, arg) {\n\tvar cacheKey = isPrimitive(arg) ? arg : serializer(arg);\n\n\tvar computedValue = cache.get(cacheKey);\n\tif (typeof computedValue === 'undefined') {\n\t\tcomputedValue = fn.call(this, arg);\n\t\tcache.set(cacheKey, computedValue);\n\t}\n\n\treturn computedValue;\n}\n\nfunction variadic(fn, cache, serializer) {\n\tvar args = Array.prototype.slice.call(arguments, 3);\n\tvar cacheKey = serializer(args);\n\n\tvar computedValue = cache.get(cacheKey);\n\tif (typeof computedValue === 'undefined') {\n\t\tcomputedValue = fn.apply(this, args);\n\t\tcache.set(cacheKey, computedValue);\n\t}\n\n\treturn computedValue;\n}\n\nfunction assemble(fn, context, strategy, cache, serialize) {\n\treturn strategy.bind(context, fn, cache, serialize);\n}\n\nfunction strategyDefault(fn, options) {\n\tvar strategy = fn.length === 1 ? monadic : variadic;\n\n\treturn assemble(fn, this, strategy, options.cache.create(), options.serializer);\n}\n\nfunction strategyVariadic(fn, options) {\n\tvar strategy = variadic;\n\n\treturn assemble(fn, this, strategy, options.cache.create(), options.serializer);\n}\n\nfunction strategyMonadic(fn, options) {\n\tvar strategy = monadic;\n\n\treturn assemble(fn, this, strategy, options.cache.create(), options.serializer);\n}\n\n//\n// Serializer\n//\n\nconst serializerDefault = JSON.stringify;\n\n//\n// Cache\n//\n\nfunction ObjectWithoutPrototypeCache() {\n\tthis.cache = Object.create(null);\n}\n\nObjectWithoutPrototypeCache.prototype.has = function (key) {\n\treturn key in this.cache;\n};\n\nObjectWithoutPrototypeCache.prototype.get = function (key) {\n\treturn this.cache[key];\n};\n\nObjectWithoutPrototypeCache.prototype.set = function (key, value) {\n\tthis.cache[key] = value;\n};\n\nvar cacheDefault = {\n\tcreate: function create() {\n\t\treturn new ObjectWithoutPrototypeCache();\n\t},\n};\n\n//\n// API\n//\n\nexport default memoize;\nexport const strategies = {\n\tvariadic: strategyVariadic,\n\tmonadic: strategyMonadic,\n};\n","import memoize from './memoize';\n\nexport type DragBoundsCoords = {\n\t/** Number of pixels from left of the document */\n\tleft: number;\n\n\t/** Number of pixels from top of the document */\n\ttop: number;\n\n\t/** Number of pixels from the right side of document */\n\tright: number;\n\n\t/** Number of pixels from the bottom of the document */\n\tbottom: number;\n};\n\nexport type DragAxis = 'both' | 'x' | 'y' | 'none';\n\nexport type DragBounds =\n\t| HTMLElement\n\t| Partial<DragBoundsCoords>\n\t| 'parent'\n\t| 'body'\n\t| (string & Record<never, never>);\n\nexport type DragOptions = {\n\t/**\n\t * Optionally limit the drag area\n\t *\n\t * Accepts `parent` as prefixed value, and limits it to its parent.\n\t *\n\t * Or, you can specify any selector and it will be bound to that.\n\t *\n\t * **Note**: We don't check whether the selector is bigger than the node element.\n\t * You yourself will have to make sure of that, or it may lead to strange behavior\n\t *\n\t * Or, finally, you can pass an object of type `{ top: number; right: number; bottom: number; left: number }`.\n\t * These mimic the css `top`, `right`, `bottom` and `left`, in the sense that `bottom` starts from the bottom of the window, and `right` from right of window.\n\t * If any of these properties are unspecified, they are assumed to be `0`.\n\t *\n\t * @example\n\t * ```svelte\n\t * <!-- Bound to parent element -->\n\t * <div use:draggable={{ bounds: 'parent' }}>\n\t *   Hello\n\t * </div>\n\t * ```\n\t *\n\t * @example\n\t * ```svelte\n\t * <!-- Bound to body -->\n\t * <div use:draggable={{ bounds: 'body' }}>\n\t *   Hello\n\t * </div>\n\t * ```\n\t *\n\t * @example\n\t * ```svelte\n\t * <!-- Bound to arbitrary coordinates -->\n\t * <div use:draggable={{ bounds: { top: 100, right: 100, bottom: 100, left: 100 } }}>\n\t *   Hello\n\t * </div>\n\t * ```\n\t */\n\tbounds?: DragBounds;\n\n\t/**\n\t * Axis on which the element can be dragged on. Valid values: `both`, `x`, `y`, `none`.\n\t *\n\t * - `both` - Element can move in any direction\n\t * - `x` - Only horizontal movement possible\n\t * - `y` - Only vertical movement possible\n\t * - `none` - No movement at all\n\t *\n\t * @default 'both'\n\t *\n\t * @example\n\t * ```svelte\n\t * <!-- Drag only in x direction -->\n\t * <div use:draggable={{ axis: 'x' }}>\n\t *   Text\n\t * </div>\n\t * ```\n\t */\n\taxis?: DragAxis;\n\n\t/**\n\t * If true, uses `translate3d` instead of `translate` to move the element around, and the hardware acceleration kicks in.\n\t *\n\t * `true` by default, but can be set to `false` if [blurry text issue](https://developpaper.com/question/why-does-the-use-of-css3-translate3d-result-in-blurred-display/) occur\n\t *\n\t * @default true\n\t *\n\t * @example\n\t * ```svelte\n\t * <!-- Disable GPU acceleration -->\n\t * <div use:draggable={{ gpuAcceleration: false }}>\n\t *   Text\n\t * </div>\n\t * ```\n\t */\n\tgpuAcceleration?: boolean;\n\n\t/**\n\t * Applies `user-select: none` on `<body />` element when dragging,\n\t * to prevent the irritating effect where dragging doesn't happen and the text is selected.\n\t * Applied when dragging starts and removed when it stops.\n\t *\n\t * Can be disabled using this option\n\t *\n\t * @default true\n\t *\n\t * @example\n\t * ```svelte\n\t * <!-- Do not disable user selection -->\n\t * <div use:draggable={{ applyUserSelectHack: false }}>\n\t *   Text\n\t * </div>\n\t * ```\n\t */\n\tapplyUserSelectHack?: boolean;\n\n\t/**\n\t * Ignores touch events with more than 1 touch.\n\t * This helps when you have multiple elements on a canvas where you want to implement\n\t * pinch-to-zoom behaviour.\n\t *\n\t * @default false\n\t *\n\t * @example\n\t * ```svelte\n\t * <!-- Ignore Multitouch -->\n\t * <div use:draggable={{ ignoreMultitouch: true }}>\n\t *   Text\n\t * </div>\n\t * ```\n\t */\n\tignoreMultitouch?: boolean;\n\n\t/**\n\t * Disables dragging altogether.\n\t *\n\t * @default false\n\t *\n\t * @example\n\t * ```svelte\n\t * <!-- Disable it entirely -->\n\t * <div use:draggable={{ disabled: true }}>\n\t *   Text\n\t * </div>\n\t * ```\n\t */\n\tdisabled?: boolean;\n\n\t/**\n\t * Applies a grid on the page to which the element snaps to when dragging, rather than the default continuous grid.\n\t *\n\t * `Note`: If you're programmatically creating the grid, do not set it to [0, 0] ever, that will stop drag at all. Set it to `undefined`.\n\t *\n\t * @default undefined\n\t *\n\t * @example\n\t * ```svelte\n\t * <!-- Snap to a grid of 10 by 10 -->\n\t * <div use:draggable={{ grid: [10, 10] }}>\n\t *   Text\n\t * </div>\n\t * ```\n\t */\n\tgrid?: [number, number];\n\n\t/**\n\t * Control the position manually with your own state\n\t *\n\t * By default, the element will be draggable by mouse/finger, and all options will work as default while dragging.\n\t *\n\t * But changing the `position` option will also move the draggable around. These parameters are reactive,\n\t * so using Svelte's reactive variables as values for position will work like a charm.\n\t *\n\t *\n\t * Note: If you set `disabled: true`, you'll still be able to move the draggable through state variables. Only the user interactions won't work\n\t *\n\t * Examples:\n\t *\n\t * [Changing with inputs](https://svelte.dev/repl/e1e707358b37467ba272891715878a1d?version=3.44.1)\n\t *\n\t * [Changing with Sliders](https://svelte.dev/repl/6b437a1cdbfc4c748520a72330c6395b?version=3.44.1)\n\t *\n\t * [Draggable only through external state, not user input](https://svelte.dev/repl/0eae169f272e41ba9c07ef222ed2bf66?version=3.44.1)\n\t *\n\t * [Comes back to original position after drag end](https://svelte.dev/repl/83d3aa8c5e154b7baf1a9c417c217d2e?version=3.44.1)\n\t *\n\t * [Comes back to original position with transition](https://svelte.dev/repl/bc84ed4ca22f45acbc28de3e33199883?version=3.44.1)\n\t */\n\tposition?: { x: number; y: number };\n\n\t/**\n\t * CSS Selector of an element inside the parent node(on which `use:draggable` is applied).\n\t *\n\t * If it is provided, Trying to drag inside the `cancel` selector will prevent dragging.\n\t *\n\t * @default undefined\n\t *\n\t * @example\n\t * <!-- Grid has a cancel element -->\n\t * <div use:draggable={{ cancel: '.cancel' }}>\n\t *   Text\n\t *   <div class=\"cancel\">This won't drag</div>\n\t * </div>\n\t * ```\n\t */\n\tcancel?: string | HTMLElement;\n\n\t/**\n\t * CSS Selector of an element inside the parent node(on which `use:draggable` is applied).\n\t *\n\t * If it is provided, Only clicking and dragging on this element will allow the parent to drag, anywhere else on the parent won't work.\n\t *\n\t * @default undefined\n\t *\n\t * @example\n\t * <!-- Grid has a handle element -->\n\t * <div use:draggable={{ handle: '.handel' }}>\n\t *   This won't drag\n\t *   <div class=\"handel\">This sure will drag!!</div>\n\t * </div>\n\t * ```\n\t */\n\thandle?: string | HTMLElement;\n\n\t/**\n\t * Class to apply on the element on which `use:draggable` is applied.\n\t * Note that if `handle` is provided, it will still apply class on the parent element, **NOT** the handle\n\t *\n\t * @default 'svelte-draggable'\n\t */\n\tdefaultClass?: string;\n\n\t/**\n\t * Class to apply on the parent element when it is dragging\n\t *\n\t * @default 'svelte-draggable-dragging'\n\t */\n\tdefaultClassDragging?: string;\n\n\t/**\n\t * Class to apply on the parent element if it has been dragged at least once.\n\t *\n\t * @default 'svelte-draggable-dragged'\n\t */\n\tdefaultClassDragged?: string;\n\n\t/**\n\t * Offsets your element to the position you specify in the very beginning.\n\t * `x` and `y` should be in pixels\n\t *\n\t * @example\n\t * <!-- Place the element at (300, 200) at the very beginning -->\n\t * <div use:draggable={{ defaultPosition: { x: 300; y: 200 } }}>\n\t *   Hello\n\t * </div>\n\t * ```\n\t */\n\tdefaultPosition?: { x: number; y: number };\n\n\t/**\n\t * Fires when dragging start\n\t */\n\tonDragStart?: (data: { offsetX: number; offsetY: number; domRect: DOMRect }) => void;\n\n\t/**\n\t * Fires when dragging is going on\n\t */\n\tonDrag?: (data: { offsetX: number; offsetY: number; domRect: DOMRect }) => void;\n\n\t/**\n\t * Fires when dragging ends\n\t */\n\tonDragEnd?: (data: { offsetX: number; offsetY: number; domRect: DOMRect }) => void;\n};\n\nconst DEFAULT_CLASS = {\n\tMAIN: 'svelte-draggable',\n\tDRAGGING: 'svelte-draggable-dragging',\n\tDRAGGED: 'svelte-draggable-dragged',\n};\n\nexport const draggable = (node: HTMLElement, options: DragOptions = {}) => {\n\tlet {\n\t\tbounds,\n\t\taxis = 'both',\n\t\tgpuAcceleration = true,\n\t\tapplyUserSelectHack = true,\n\t\tdisabled = false,\n\t\tignoreMultitouch = false,\n\n\t\tgrid,\n\n\t\tposition,\n\n\t\tcancel,\n\t\thandle,\n\n\t\tdefaultClass = DEFAULT_CLASS.MAIN,\n\t\tdefaultClassDragging = DEFAULT_CLASS.DRAGGING,\n\t\tdefaultClassDragged = DEFAULT_CLASS.DRAGGED,\n\n\t\tdefaultPosition = { x: 0, y: 0 },\n\n\t\tonDragStart,\n\t\tonDrag,\n\t\tonDragEnd,\n\t} = options;\n\n\tconst tick = new Promise(requestAnimationFrame);\n\n\tlet active = false;\n\n\tlet [translateX, translateY] = [0, 0];\n\tlet [initialX, initialY] = [0, 0];\n\n\t// The offset of the client position relative to the node's top-left corner\n\tlet [clientToNodeOffsetX, clientToNodeOffsetY] = [0, 0];\n\n\tlet { x: xOffset, y: yOffset } = { x: position?.x ?? 0, y: position?.y ?? 0 } ?? defaultPosition;\n\n\tsetTranslate(xOffset, yOffset, node, gpuAcceleration);\n\n\tlet canMoveInX: boolean;\n\tlet canMoveInY: boolean;\n\n\tlet bodyOriginalUserSelectVal = '';\n\n\tlet computedBounds: DragBoundsCoords;\n\tlet nodeRect: DOMRect;\n\n\tlet dragEl: HTMLElement | undefined;\n\tlet cancelEl: HTMLElement | undefined;\n\n\tlet isControlled = !!position;\n\n\tconst getEventData = () => ({\n\t\toffsetX: translateX,\n\t\toffsetY: translateY,\n\t\tdomRect: node.getBoundingClientRect(),\n\t});\n\n\tfunction fireSvelteDragStartEvent(node: HTMLElement) {\n\t\tconst data = getEventData();\n\t\tnode.dispatchEvent(new CustomEvent('svelte-drag:start', { detail: data }));\n\t\tonDragStart?.(data);\n\t}\n\n\tfunction fireSvelteDragStopEvent(node: HTMLElement) {\n\t\tconst data = getEventData();\n\n\t\tnode.dispatchEvent(new CustomEvent('svelte-drag:end', { detail: data }));\n\t\tonDragEnd?.(data);\n\t}\n\n\tfunction fireSvelteDragEvent(node: HTMLElement) {\n\t\tconst data = getEventData();\n\n\t\tnode.dispatchEvent(new CustomEvent('svelte-drag', { detail: data }));\n\t\tonDrag?.(data);\n\t}\n\n\tconst listen = addEventListener;\n\n\tlisten('touchstart', dragStart, false);\n\tlisten('touchend', dragEnd, false);\n\tlisten('touchmove', drag, false);\n\n\tlisten('mousedown', dragStart, false);\n\tlisten('mouseup', dragEnd, false);\n\tlisten('mousemove', drag, false);\n\n\t// On mobile, touch can become extremely janky without it\n\tnode.style.touchAction = 'none';\n\n\tconst calculateInverseScale = () => {\n\t\t// Calculate the current scale of the node\n\t\tlet inverseScale = node.offsetWidth / nodeRect.width;\n\t\tif (isNaN(inverseScale)) inverseScale = 1;\n\t\treturn inverseScale;\n\t};\n\n\tfunction dragStart(e: TouchEvent | MouseEvent) {\n\t\tif (disabled) return;\n\t\tif (ignoreMultitouch && e.type === 'touchstart' && (e as TouchEvent).touches.length > 1) return;\n\n\t\tnode.classList.add(defaultClass);\n\n\t\tdragEl = getHandleEl(handle, node);\n\t\tcancelEl = getCancelElement(cancel, node);\n\n\t\tcanMoveInX = ['both', 'x'].includes(axis);\n\t\tcanMoveInY = ['both', 'y'].includes(axis);\n\n\t\t// Compute bounds\n\t\tif (typeof bounds !== 'undefined') {\n\t\t\tcomputedBounds = computeBoundRect(bounds, node);\n\t\t}\n\n\t\t// Compute current node's bounding client Rectangle\n\t\tnodeRect = node.getBoundingClientRect();\n\n\t\tif (isString(handle) && isString(cancel) && handle === cancel)\n\t\t\tthrow new Error(\"`handle` selector can't be same as `cancel` selector\");\n\n\t\tif (cancelEl?.contains(dragEl))\n\t\t\tthrow new Error(\n\t\t\t\t\"Element being dragged can't be a child of the element on which `cancel` is applied\"\n\t\t\t);\n\n\t\tif (dragEl.contains(<HTMLElement>e.target) && !cancelEl?.contains(<HTMLElement>e.target))\n\t\t\tactive = true;\n\n\t\tif (!active) return;\n\n\t\tif (applyUserSelectHack) {\n\t\t\t// Apply user-select: none on body to prevent misbehavior\n\t\t\tbodyOriginalUserSelectVal = document.body.style.userSelect;\n\t\t\tdocument.body.style.userSelect = 'none';\n\t\t}\n\n\t\t// Dispatch custom event\n\t\tfireSvelteDragStartEvent(node);\n\n\t\tconst { clientX, clientY } = isTouchEvent(e) ? e.touches[0] : e;\n\t\tconst inverseScale = calculateInverseScale();\n\n\t\tif (canMoveInX) initialX = clientX - xOffset / inverseScale;\n\t\tif (canMoveInY) initialY = clientY - yOffset / inverseScale;\n\n\t\t// Only the bounds uses these properties at the moment,\n\t\t// may open up in the future if others need it\n\t\tif (computedBounds) {\n\t\t\tclientToNodeOffsetX = clientX - nodeRect.left;\n\t\t\tclientToNodeOffsetY = clientY - nodeRect.top;\n\t\t}\n\t}\n\n\tfunction dragEnd() {\n\t\tif (!active) return;\n\n\t\t// Apply class defaultClassDragged\n\t\tnode.classList.remove(defaultClassDragging);\n\t\tnode.classList.add(defaultClassDragged);\n\n\t\tif (applyUserSelectHack) document.body.style.userSelect = bodyOriginalUserSelectVal;\n\n\t\tfireSvelteDragStopEvent(node);\n\n\t\tif (canMoveInX) initialX = translateX;\n\t\tif (canMoveInX) initialY = translateY;\n\n\t\tactive = false;\n\t}\n\n\tfunction drag(e: TouchEvent | MouseEvent) {\n\t\tif (!active) return;\n\n\t\t// Apply class defaultClassDragging\n\t\tnode.classList.add(defaultClassDragging);\n\n\t\te.preventDefault();\n\n\t\tnodeRect = node.getBoundingClientRect();\n\n\t\tconst { clientX, clientY } = isTouchEvent(e) ? e.touches[0] : e;\n\n\t\t// Get final values for clamping\n\t\tlet [finalX, finalY] = [clientX, clientY];\n\n\t\tconst inverseScale = calculateInverseScale();\n\n\t\tif (computedBounds) {\n\t\t\t// Client position is limited to this virtual boundary to prevent node going out of bounds\n\t\t\tconst virtualClientBounds: DragBoundsCoords = {\n\t\t\t\tleft: computedBounds.left + clientToNodeOffsetX,\n\t\t\t\ttop: computedBounds.top + clientToNodeOffsetY,\n\t\t\t\tright: computedBounds.right + clientToNodeOffsetX - nodeRect.width,\n\t\t\t\tbottom: computedBounds.bottom + clientToNodeOffsetY - nodeRect.height,\n\t\t\t};\n\n\t\t\tfinalX = clamp(finalX, virtualClientBounds.left, virtualClientBounds.right);\n\t\t\tfinalY = clamp(finalY, virtualClientBounds.top, virtualClientBounds.bottom);\n\t\t}\n\n\t\tif (Array.isArray(grid)) {\n\t\t\tlet [xSnap, ySnap] = grid;\n\n\t\t\tif (isNaN(+xSnap) || xSnap < 0)\n\t\t\t\tthrow new Error('1st argument of `grid` must be a valid positive number');\n\n\t\t\tif (isNaN(+ySnap) || ySnap < 0)\n\t\t\t\tthrow new Error('2nd argument of `grid` must be a valid positive number');\n\n\t\t\tlet [deltaX, deltaY] = [finalX - initialX, finalY - initialY];\n\t\t\t[deltaX, deltaY] = snapToGrid(\n\t\t\t\t[Math.floor(xSnap / inverseScale), Math.floor(ySnap / inverseScale)],\n\t\t\t\tdeltaX,\n\t\t\t\tdeltaY\n\t\t\t);\n\n\t\t\t[finalX, finalY] = [initialX + deltaX, initialY + deltaY];\n\t\t}\n\n\t\tif (canMoveInX) translateX = (finalX - initialX) * inverseScale;\n\t\tif (canMoveInY) translateY = (finalY - initialY) * inverseScale;\n\n\t\t[xOffset, yOffset] = [translateX, translateY];\n\n\t\tfireSvelteDragEvent(node);\n\n\t\ttick.then(() => setTranslate(translateX, translateY, node, gpuAcceleration));\n\t\t// Promise.resolve().then(() => setTranslate(translateX, translateY, node, gpuAcceleration));\n\t}\n\n\treturn {\n\t\tdestroy: () => {\n\t\t\tconst unlisten = removeEventListener;\n\n\t\t\tunlisten('touchstart', dragStart, false);\n\t\t\tunlisten('touchend', dragEnd, false);\n\t\t\tunlisten('touchmove', drag, false);\n\n\t\t\tunlisten('mousedown', dragStart, false);\n\t\t\tunlisten('mouseup', dragEnd, false);\n\t\t\tunlisten('mousemove', drag, false);\n\t\t},\n\t\tupdate: (options: DragOptions) => {\n\t\t\t// Update all the values that need to be changed\n\t\t\taxis = options.axis || 'both';\n\t\t\tdisabled = options.disabled ?? false;\n\t\t\tignoreMultitouch = options.ignoreMultitouch ?? false;\n\t\t\thandle = options.handle;\n\t\t\tbounds = options.bounds;\n\t\t\tcancel = options.cancel;\n\t\t\tapplyUserSelectHack = options.applyUserSelectHack ?? true;\n\t\t\tgrid = options.grid;\n\t\t\tgpuAcceleration = options.gpuAcceleration ?? true;\n\n\t\t\tconst dragged = node.classList.contains(defaultClassDragged);\n\n\t\t\tnode.classList.remove(defaultClass, defaultClassDragged);\n\n\t\t\tdefaultClass = options.defaultClass ?? DEFAULT_CLASS.MAIN;\n\t\t\tdefaultClassDragging = options.defaultClassDragging ?? DEFAULT_CLASS.DRAGGING;\n\t\t\tdefaultClassDragged = options.defaultClassDragged ?? DEFAULT_CLASS.DRAGGED;\n\n\t\t\tnode.classList.add(defaultClass);\n\n\t\t\tif (dragged) node.classList.add(defaultClassDragged);\n\n\t\t\tif (isControlled) {\n\t\t\t\txOffset = translateX = options.position?.x ?? translateX;\n\t\t\t\tyOffset = translateY = options.position?.y ?? translateY;\n\n\t\t\t\ttick.then(() => setTranslate(translateX, translateY, node, gpuAcceleration));\n\t\t\t}\n\t\t},\n\t};\n};\n\nfunction isTouchEvent(event: MouseEvent | TouchEvent): event is TouchEvent {\n\treturn Boolean((event as TouchEvent).touches && (event as TouchEvent).touches.length);\n}\n\nfunction clamp(val: number, min: number, max: number) {\n\treturn Math.min(Math.max(val, min), max);\n}\n\nfunction isString(val: unknown): val is string {\n\treturn typeof val === 'string';\n}\n\nconst snapToGrid = memoize(\n\t([xSnap, ySnap]: [number, number], pendingX: number, pendingY: number): [number, number] => {\n\t\tconst x = Math.round(pendingX / xSnap) * xSnap;\n\t\tconst y = Math.round(pendingY / ySnap) * ySnap;\n\t\treturn [x, y];\n\t}\n);\n\nfunction getHandleEl(handle: DragOptions['handle'], node: HTMLElement) {\n\tif (!handle) return node;\n\n\tif (handle instanceof HTMLElement) return handle;\n\n\t// Valid!! Let's check if this selector exists or not\n\tconst handleEl = node.querySelector<HTMLElement>(handle);\n\tif (handleEl === null)\n\t\tthrow new Error(\n\t\t\t'Selector passed for `handle` option should be child of the element on which the action is applied'\n\t\t);\n\n\treturn handleEl!;\n}\n\nfunction getCancelElement(cancel: DragOptions['cancel'], node: HTMLElement) {\n\tif (!cancel) return;\n\n\tif (cancel instanceof HTMLElement) return cancel;\n\n\tconst cancelEl = node.querySelector<HTMLElement>(cancel);\n\n\tif (cancelEl === null)\n\t\tthrow new Error(\n\t\t\t'Selector passed for `cancel` option should be child of the element on which the action is applied'\n\t\t);\n\n\treturn cancelEl;\n}\n\nfunction computeBoundRect(bounds: DragOptions['bounds'], rootNode: HTMLElement) {\n\tif (bounds instanceof HTMLElement) return bounds.getBoundingClientRect();\n\n\tif (typeof bounds === 'object') {\n\t\t// we have the left right etc\n\t\tconst [windowWidth, windowHeight] = [window.innerWidth, window.innerHeight];\n\n\t\tconst { top = 0, left = 0, right = 0, bottom = 0 } = bounds;\n\n\t\tconst computedRight = windowWidth - right;\n\t\tconst computedBottom = windowHeight - bottom;\n\n\t\treturn { top, right: computedRight, bottom: computedBottom, left };\n\t}\n\n\t// It's a string\n\tif (bounds === 'parent') return (<HTMLElement>rootNode.parentNode).getBoundingClientRect();\n\n\tconst node = document.querySelector<HTMLElement>(<string>bounds);\n\tif (node === null)\n\t\tthrow new Error(\"The selector provided for bound doesn't exists in the document.\");\n\n\tconst computedBounds = node.getBoundingClientRect();\n\treturn computedBounds;\n}\n\nfunction setTranslate(xPos: number, yPos: number, el: HTMLElement, gpuAcceleration: boolean) {\n\tel.style.transform = gpuAcceleration\n\t\t? `translate3d(${+xPos}px, ${+yPos}px, 0)`\n\t\t: `translate(${+xPos}px, ${+yPos}px)`;\n}\n"],"mappings":"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","names":[]}