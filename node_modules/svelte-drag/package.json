{
  "name": "svelte-drag",
  "version": "3.1.0",
  "description": "Svelte Action to add dragging to your apps üòâ",
  "main": "index.js",
  "module": "index.js",
  "type": "module",
  "types": "index.d.ts",
  "files": [
    "*"
  ],
  "sideEffects": false,
  "exports": {
    ".": {
      "import": "./index.js",
      "module": "./index.js"
    },
    "./package.json": "./package.json"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/PuruVJ/svelte-drag.git"
  },
  "keywords": [
    "draggable",
    "svelte",
    "react-draggable",
    "drag",
    "svelte",
    "small",
    "tiny",
    "performant"
  ],
  "author": "Puru Vijay",
  "license": "MIT",
  "bugs": {
    "url": "https://github.com/PuruVJ/svelte-drag/issues"
  },
  "homepage": "https://github.com/PuruVJ/svelte-drag#readme",
  "readme": "# svelte-drag\n\nA lightweight Svelte Action to make your elements draggable.\n\nInspired from the amazing [react-draggable](https://github.com/react-grid-layout/react-draggable) library, and implements the same API.\n\n# Features\n\n- ü§è Tiny - Only [2.2KB](https://bundlephobia.com/package/svelte-drag) min+gzip.\n- üêá Simple - Quite simple to use, and effectively no-config required!\n- üßô‚Äç‚ôÄÔ∏è Elegant - Svelte Action, to keep the usage simple, elegant and expressive.\n- üóÉÔ∏è Highly customizable - Offers tons of options that you can modify to get different behavior.\n- ‚öõÔ∏è Reactive - Change options passed to it on the fly, it will **just work üôÇ**\n\n[Try it in Svelte REPL](https://svelte.dev/repl/fc972f90450c4945b6f2481d13eafa00?version=3.38.3)\n\n# Installing\n\n```bash\npnpm add svelte-drag\n\n# npm\nnpm install svelte-drag\n\n# yarn\nyarn add svelte-drag\n```\n\n# Usage\n\nBasic usage\n\n```svelte\n<script>\n  import { draggable } from 'svelte-drag';\n</script>\n\n<div use:draggable>Hello</div>\n```\n\nWith options\n\n```svelte\n<script>\n  import { draggable } from 'svelte-drag';\n</script>\n\n<div use:draggable={{ axis: 'x', grid: [10, 10] }}>Hello</div>\n```\n\nDefining options elsewhere with typescript\n\n```svelte\n<script lang=\"ts\">\n  import { draggable } from 'svelte-drag';\n  import type { DragOptions } from 'svelte-drag';\n\n  let options: DragOptions = {\n    axis: 'y',\n    bounds: 'parent',\n  };\n</script>\n\n<div use:draggable={options}>Hello</div>\n```\n\n# Options\n\nThere are tons of options available for this package. All of them are already documented within the code itself, so you'll never have to leave the code editor.\n\n## axis\n\n**type**: `'both' | 'x' | 'y' | 'none'`\n\n**Default Value**: `'both'`\n\nAxis on which the element can be dragged on. Valid values: `both`, `x`, `y`, `none`.\n\n- `both` - Element can move in any direction\n- `x` - Only horizontal movement possible\n- `y` - Only vertical movement possible\n- `none` - No movement at all\n\n**Examples**:\n\n```svelte\n<!-- Drag only in x direction -->\n<div use:draggable={{ axis: 'x' }}>Text</div>\n```\n\nDynamically change `axis` using radio buttons.\n\n```svelte\n<script>\nlet axis;\n</script>\n\n<div>\n  Axis:\n  <label>\n    <input type=\"radio\" bind:group={axis} value=\"both\" />\n    Both\n  </label>\n  <label>\n    <input type=\"radio\" bind:group={axis} value=\"x\" />\n    x\n  </label>\n  <label>\n    <input type=\"radio\" bind:group={axis} value=\"y\" />\n    y\n  </label>\n  <label>\n    <input type=\"radio\" bind:group={axis} value=\"none\" />\n    none\n  </label>\n</div>\n\n<!-- Dynamically change axis -->\n<div use:draggable={{ axis }}>Text</div>\n```\n\n## bounds\n\n**type**: `HTMLElement | 'parent' | string | { top?: number; right?: number; bottom?: number; left?: number }`\n\n**Default Value**: `undefined`\n\nOptionally limit the drag area\n\n`parent`: Limit to parent\n\nOr, you can specify any selector and it will be bound to that.\n\n**Note**: This library doesn't check whether the selector is bigger than the node element.\nYou yourself will have to make sure of that, or it may lead to unexpected behavior.\n\nOr, finally, you can pass an object of type `{ top: number; right: number; bottom: number; left: number }`.\nThese mimic the css `top`, `right`, `bottom` and `left`, in the sense that `bottom` starts from the bottom of the window, and `right` from right of window.\nIf any of these properties are unspecified, they are assumed to be `0`.\n\n**Examples**:\n\nBound to any element\n\n```svelte\n<div use:draggable={{ bounds: document.querySelector('.some-element') }}>Hello</div>\n```\n\nBound to parent\n\n```svelte\n<div use:draggable={{ bounds: 'parent' }}>Hello</div>\n```\n\nBound to body\n\n```svelte\n<div use:draggable={{ bounds: 'body' }}>Hello</div>\n```\n\nBound to an ancestor selector somewhere in page\n\n```svelte\n<div use:draggable={{ bounds: '.way-up-in-the-dom' }}>Hello</div>\n```\n\nManually through coordinates. Empty object means bound to the `window`.\n\n**NOTE**: It isn't strictly empty object. If you omit any property from this object, it will be assumed as `0`.\n\n```svelte\n<div use:draggable={{ bounds: {} }}>Hello</div>\n```\n\nBound only to top and bottom, and unbounded horizontally in practice by setting bounds way beyond the screen.\n\n```svelte\n<div use:draggable={{ bounds: { top: 0, bottom: 0, left: -1000, right: -1000 } }}>Hello</div>\n```\n\n## gpuAcceleration\n\n**type**: `boolean`\n\n**Default value**: `true`\n\nIf true, uses `translate3d` instead of `translate` to move the element around, and the hardware acceleration kicks in.\n\n`true` by default, but can be set to `false` if [blurry text issue](https://developpaper.com/question/why-does-the-use-of-css3-translate3d-result-in-blurred-display/) occurs.\n\nExample üëá\n\n```svelte\n<div use:draggable={{ gpuAcceleration: false }}>Hello</div>\n```\n\n## applyUserSelectHack\n\n**type**: `boolean`\n\n**Default value**: `true`\n\nApplies `user-select: none` on `<body />` element when dragging, to prevent the irritating effect where dragging doesn't happen and the text is selected. Applied when dragging starts and removed when it stops.\n\n## ignoreMultitouch\n\n**type**: `boolean`\n\n**Default value**: `false`\n\nIgnores touch events with more than 1 touch.\nThis helps when you have multiple elements on a canvas where you want to implement pinch-to-zoom behaviour.\n\n```svelte\n<!-- Ignore Multitouch -->\n<div use:draggable={{ ignoreMultitouch: true }}>Text</div>\n```\n\n## disabled\n\n**type**: `boolean`\n\n**Default Value**: `undefined`\n\nDisables dragging.\n\n## grid\n\n**type**: `[number, number]`\n\n**Default value**: `undefined`\n\nApplies a grid on the page to which the element snaps to when dragging, rather than the default continuous grid.\n\n`Note`: If you're programmatically creating the grid, do not set it to [0, 0] ever, that will stop drag at all. Set it to `undefined` to make it continuous once again.\n\n## position\n\n**type**: `{ x: number; y: number }`\n\n**Default Value**: `undefined`\n\nControls the position of the element programmatically. Fully reactive.\n\nRead more below in the **Controlled vs Uncontrolled** section.\n\n## cancel\n\n**type**: `string | HTMLElement`\n\n**Default value**: `undefined`\n\nCSS Selector of an element inside the parent node(on which `use:draggable` is applied). If it is provided, Trying to drag inside the `cancel` selector will prevent dragging.\n\n```svelte\n<div use:draggable={{ cancel: '.cancel' }}>\n  This will drag!\n  <div class=\"cancel\">You shall not drag!!üßô‚Äç‚ôÇÔ∏è</div>\n</div>\n```\n\n## handle\n\n**type**: `string | HTMLElement`\n\n**Default Value**: `undefined`\n\nCSS Selector of an element inside the parent node(on which `use:draggable` is applied). If it is provided, Only clicking and dragging on this element will allow the parent to drag, anywhere else on the parent won't work.\n\n```svelte\n<div use:draggable={{ handle: '.handle' }}>\n  You shall not drag!!üßô‚Äç‚ôÇÔ∏è\n  <div class=\"handle\">This will drag üòÅ</div>\n</div>\n```\n\n```svelte\n<div use:draggable={{ handle }}>\n  You shall not drag!!üßô‚Äç‚ôÇÔ∏è\n  <div class=\"handle\" bind:this={handle}>This will drag üòÅ</div>\n</div>\n```\n\n## defaultClass\n\n**type**: `string`\n\n**Default Value**: `'svelte-draggable'`\n\nClass to apply on the element on which `use:draggable` is applied. <br/><br/> Note that if `handle` is provided, it will still apply class on the parent element, **NOT** the handle\n\n## defaultClassDragging\n\n**type**: `string`\n\n**Default Value**: `'svelte-draggable-dragging'`\n\nClass to apply on the parent element when it is dragging\n\n## defaultClassDragged\n\n**type**: `string`\n\n**Default Value**: `'svelte-draggable-dragged'`\n\nClass to apply on the parent element if it has been dragged at least once.\n\n## defaultPosition\n\n**type**: `{ x: number; y: number }`\n\n**Default Value**: `{ x: 0, y: 0 }`\n\nOffsets your element to the position you specify in the very beginning. `x` and `y` should be in pixels\n\n## onDragStart\n\n**type**: `(data: { offsetX: number; offsetY: number }) => void`\n\n**Default Value**: `undefined`\n\nFires when dragging start.\n\n## onDrag\n\n**type**: `(data: { offsetX: number; offsetY: number }) => void`\n\n**Default Value**: `undefined`\n\nFires when dragging is going on.\n\n## onDragEnd\n\n**type**: `(data: { offsetX: number; offsetY: number }) => void`\n\n**Default Value**: `undefined`\n\nFires when dragging ends.\n\n# Events\n\n`svelte-drag` emits 3 events, `on:svelte-drag`, `on:svelte-drag:start` & `on:svelte-drag:end`. These are all custom events, and can be listened on the node the `use:draggable` is applied to\n\nExample:\n\n```svelte\n<div\n  use:draggable\n  on:svelte-drag:start={(e) => console.log('Dragging started', e)}\n  on:svelte-drag={(e) => console.log(e.detail)}\n  on:svelte-drag:end={(e) => console.log('Dragging stopped', e)}\n>\n  Hello\n</div>\n```\n\nEvent signatures:\n\n`on:svelte-drag:start`: `(e: CustomEvent<{ offsetX: number; offsetY: number; domRect: DOMRect }>) => void`. Provides the initial offset when dragging starts, on the `e.detail` object.\n\n`on:svelte-drag:`: `(e: CustomEvent<{ offsetX: number; offsetY: number; domRect: DOMRect }>`. Provides how far the element has been dragged from it's original position in `x` and `y` coordinates on the `event.detail` object\n\n`on:svelte-drag:end`: `(e: CustomEvent<{ offsetX: number; offsetY: number; domRect: DOMRect }>) => void`. No internal state provided to `event.detail`. Provides the final offset when dragging ends, on the `e.detail` object.\n\n### Alternative\n\nIf you scroll up, you'll see 3 options, `onDragStart`, `onDrag` and `onDragEnd`. These are basically event handlers that you specify as methods of the options object.\n\nWhy have two ways to listen to events? Because at the time of writing, the Svelte extension for VSCode doesn't work fully well with custom events when using TypeScript, even after they're explicitly typed by the user in TypeScript.\n\nI take TypeScript very seriously, hence I am going an extra step to provide duplicate implementations for event handling.\n\nHow to use events-as-options? The syntax is similar to the custom events one üëá\n\n```svelte\n<div\n  use:draggable={{\n    onDragStart: ({ offsetX, offsetY, domRect }) => {\n      // Do something\n    },\n    onDrag: ({ offsetX, offsetY, domRect }) => {\n      // Do something\n    },\n    onDragEnd: ({ offsetX, offsetY, domRect }) => {\n      // Do something\n    },\n\n  }}\n  class=\"box\"\n/>\n```\n\nUltimately, this gives everyone a choice. non-TypeScript users will prefer the `on:svelte-drag:*` method because it is more idiomatic, and TypeScript users can go with events-as-options way to get better TS experience\n\n> Note: Do not use same event in two different ways. I.E., having `on:svelte-drag:start` and `onDragStart` at once will have both fire at the time when dragging starts. Use only one at a time.\n\nIf you're a TypeScript user, read on below üëá\n\n# TypeScript\n\nThis library ships with proper TypeScript typings, for the best Developer Experience, whether authoring JS or TS.\n\n## Types Exported from package\n\nThis package exports these types you can use:\n\n```ts\nimport type { DragAxis, DragBounds, DragBoundsCoords, DragOptions } from 'svelte-drag';\n```\n\n`DragOptions` is the documented list of all options provided by the component.\n\n`DragAxis` is the type of `axis` option, and is equal to `'both' | 'x' | 'y' | 'none'`.\n\n`DragBounds` is `'parent' | string | Partial<DragBoundsCoords>`, the complete type of `bounds` option.\n\n`DragBoundsCoords` is when you're specifying the `bounds` field using an object, this is the type needed for that.\n\n```ts\nexport type DragBoundsCoords = {\n\t/** Number of pixels from left of the window */\n\tleft: number;\n\n\t/** Number of pixels from top of the window */\n\ttop: number;\n\n\t/** Number of pixels from the right side of window */\n\tright: number;\n\n\t/** Number of pixels from the bottom of the window */\n\tbottom: number;\n};\n```\n\n# Controlled vs Uncontrolled\n\nThis is taken straight from React's philosophy(After all, this package is inspired from [react-draggable](https://github.com/react-grid-layout/react-draggable)).\n\nUncontrolled means your app doesn't control the dragging of the app. Meaning, the user drags the element, it changes position, and you do something with that action. You yourself don't change position of the element or anything. This is the default behavior of this library.\n\nControlled means your app, using state variables, changes the position of the element, or in simple terms, programmatically drag the element. You basically set the `position` property to `{ x: 10, y: 50 }`(or any other numbers), and voila! yur now controlling the position of the element programmatically ü•≥ü•≥\n\nOFC, this library doesn't go fully **Controlled**. The user can still drag it around even when `position` is set.\n\nSo, when you change `position`, the element position changes. However, when the element is dragged by user interaction, `position` is not changed. This is done intentionally, as two-way data binding here isn't possible and also will lead to unexpected behavior. To keep the `position` variable up to date, use the `on:svelte-drag` event to keep your state up to date to the draggable's internal state.\n\nTo have it be strictly **Controlled**, meaning it can only be moved programmatically, add the `disabled` option to your draggable element's config\n\n```svelte\n<div use:draggable={{ position: { x: 0, y: 10 }, disabled: true }} />\n```\n\nHere are a bunch of examples showing controlled behavior üëá\n\n1. [Changing with inputs](https://svelte.dev/repl/e1e707358b37467ba272891715878a1d?version=3.44.1)\n2. [Changing with Sliders](https://svelte.dev/repl/6b437a1cdbfc4c748520a72330c6395b?version=3.44.1)\n3. [Draggable only through external state, not user input](https://svelte.dev/repl/0eae169f272e41ba9c07ef222ed2bf66?version=3.44.1)\n4. [Comes back to original position after drag end](https://svelte.dev/repl/83d3aa8c5e154b7baf1a9c417c217d2e?version=3.44.1)\n5. [Comes back to original position with transition](https://svelte.dev/repl/bc84ed4ca22f45acbc28de3e33199883?version=3.44.1)\n\n# Why an action and not a component?\n\nIn case you're wondering why this library is an action, and not a component, the answer is simple: Actions usage is much much simpler and elegant than a component for this case could ever be.\n\nIf it were a component, its syntax would be like this üëá\n\n```svelte\n<Draggable axis=\"x\" grid={[50, 50]}>\n  <div>\n    Hello\n  </div>\n</Draggable>\n```\n\nThis is ok, but what if there are more than 2 elements at the top.\n\n```svelte\n<Draggable axis=\"x\" grid={[50, 50]}>\n  <div>\n    Hello\n  </div>\n\n  <div>\n    You shall not pass ~ Gandalf the wizard\n  </div>\n</Draggable>\n```\n\nThis poses a problem: How would I decide which of these to make a draggable? Ofc, I could wrap the `<slot />` in a `<div>`, apply event listeners on it, set it to `display: contents`, but it would add an extra DOM element, and sometimes, that alone can make a huge difference!\n\nSo to not add a wrapper myself, I would need to write here in docs to pass only one root element, and give an error when I detect multiple. or I'd need to enforce passing the ref of the element into the component using `bind:this`, like this üëá\n\n```svelte\n<script>\nlet ref;\n</script>\n\n<Draggable nodeRef={ref} axis=\"x\" grid={[50, 50]}>\n  <div bind:this={ref}>\n    Hello\n  </div>\n</Draggable>\n```\n\nYou'd have to bind the element ref which you want to make a draggable, and pass it to the component.\n\nThis is doable, but it adds an unnecessary amount of API layer, and the code isn't idiomatic and elegant, not to mention how much extra code I would have to add as the library author.\n\nNot to mention, it would require much more work to make it SSR compliant, which makes no sense, cuz the server isn't dragging elements around, so why need to SSR it in the first place ¬Ø\\\\\\_(„ÉÑ)\\_/¬Ø. I would have to add `browser` checks everywhere to make it work, which is less than ideal.\n\nOn the other hand, as an action, this gives ultimate control to both the user and me.\n\n```svelte\n<div use:draggable={{ axis: 'x', grid: [50, 50] }}>\n  Hello\n</div>\n```\n\nThis is extremely simple, elegant and expressive. By applying the action, you are specifying which element you want to be draggable, without any extra overhead. It just works!! And Actions aren't run in SSR, so your app will server render without errors caused from this library, and will spare me the gruelling task of adding browser checks everywhere!! It's a win win for everyone!! üôÇ\n\n# Contributing\n\nFeel free to open an issue with a bug or feature request.\n\nIf you wish to make a PR fixing something, please open an issue about it first!\n\n## Help needed üõë\n\nThis library lacks something very important: **Automated Tests!**\n\nI'll be straight about this: I don't know how to write tests. I've tried, but not been able to.\n\nSo I need your help. If you wish to contribute and can add tests here, it would be great for everyone using this! üôÇ\n\nSpecifications here: [#7](https://github.com/PuruVJ/svelte-drag/issues/7)\n\n# License\n\nMIT License\n"
}