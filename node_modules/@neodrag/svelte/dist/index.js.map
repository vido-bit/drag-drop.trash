{"version":3,"file":"index.js","sources":["../src/memoize.js","../src/index.ts"],"sourcesContent":["//\n// Code from `fast-memoize`\n//\n\nfunction memoize(fn, options) {\n\tvar cache = options?.cache ?? cacheDefault;\n\tvar serializer = options?.serializer ?? serializerDefault;\n\tvar strategy = options?.strategy ?? strategyDefault;\n\n\treturn strategy(fn, {\n\t\tcache: cache,\n\t\tserializer: serializer,\n\t});\n}\n\n//\n// Strategy\n//\n\nfunction isPrimitive(value) {\n\treturn value == null || typeof value === 'number' || typeof value === 'boolean'; // || typeof value === \"string\" 'unsafe' primitive for our needs\n}\n\nfunction monadic(fn, cache, serializer, arg) {\n\tvar cacheKey = isPrimitive(arg) ? arg : serializer(arg);\n\n\tvar computedValue = cache.get(cacheKey);\n\tif (typeof computedValue === 'undefined') {\n\t\tcomputedValue = fn.call(this, arg);\n\t\tcache.set(cacheKey, computedValue);\n\t}\n\n\treturn computedValue;\n}\n\nfunction variadic(fn, cache, serializer) {\n\tvar args = Array.prototype.slice.call(arguments, 3);\n\tvar cacheKey = serializer(args);\n\n\tvar computedValue = cache.get(cacheKey);\n\tif (typeof computedValue === 'undefined') {\n\t\tcomputedValue = fn.apply(this, args);\n\t\tcache.set(cacheKey, computedValue);\n\t}\n\n\treturn computedValue;\n}\n\nfunction assemble(fn, context, strategy, cache, serialize) {\n\treturn strategy.bind(context, fn, cache, serialize);\n}\n\nfunction strategyDefault(fn, options) {\n\tvar strategy = fn.length === 1 ? monadic : variadic;\n\n\treturn assemble(fn, this, strategy, options.cache.create(), options.serializer);\n}\n\nfunction strategyVariadic(fn, options) {\n\tvar strategy = variadic;\n\n\treturn assemble(fn, this, strategy, options.cache.create(), options.serializer);\n}\n\nfunction strategyMonadic(fn, options) {\n\tvar strategy = monadic;\n\n\treturn assemble(fn, this, strategy, options.cache.create(), options.serializer);\n}\n\n//\n// Serializer\n//\n\nconst serializerDefault = JSON.stringify;\n\n//\n// Cache\n//\n\nfunction ObjectWithoutPrototypeCache() {\n\tthis.cache = Object.create(null);\n}\n\nObjectWithoutPrototypeCache.prototype.has = function (key) {\n\treturn key in this.cache;\n};\n\nObjectWithoutPrototypeCache.prototype.get = function (key) {\n\treturn this.cache[key];\n};\n\nObjectWithoutPrototypeCache.prototype.set = function (key, value) {\n\tthis.cache[key] = value;\n};\n\nvar cacheDefault = {\n\tcreate: function create() {\n\t\treturn new ObjectWithoutPrototypeCache();\n\t},\n};\n\n//\n// API\n//\n\nexport default memoize;\nexport const strategies = {\n\tvariadic: strategyVariadic,\n\tmonadic: strategyMonadic,\n};\n","import memoize from './memoize';\n\nexport type DragBoundsCoords = {\n\t/** Number of pixels from left of the document */\n\tleft: number;\n\n\t/** Number of pixels from top of the document */\n\ttop: number;\n\n\t/** Number of pixels from the right side of document */\n\tright: number;\n\n\t/** Number of pixels from the bottom of the document */\n\tbottom: number;\n};\n\nexport type DragAxis = 'both' | 'x' | 'y' | 'none';\n\nexport type DragBounds =\n\t| HTMLElement\n\t| Partial<DragBoundsCoords>\n\t| 'parent'\n\t| 'body'\n\t| (string & Record<never, never>);\n\nexport type DragOptions = {\n\t/**\n\t * Optionally limit the drag area\n\t *\n\t * Accepts `parent` as prefixed value, and limits it to its parent.\n\t *\n\t * Or, you can specify any selector and it will be bound to that.\n\t *\n\t * **Note**: We don't check whether the selector is bigger than the node element.\n\t * You yourself will have to make sure of that, or it may lead to strange behavior\n\t *\n\t * Or, finally, you can pass an object of type `{ top: number; right: number; bottom: number; left: number }`.\n\t * These mimic the css `top`, `right`, `bottom` and `left`, in the sense that `bottom` starts from the bottom of the window, and `right` from right of window.\n\t * If any of these properties are unspecified, they are assumed to be `0`.\n\t */\n\tbounds?: DragBounds;\n\n\t/**\n\t * Axis on which the element can be dragged on. Valid values: `both`, `x`, `y`, `none`.\n\t *\n\t * - `both` - Element can move in any direction\n\t * - `x` - Only horizontal movement possible\n\t * - `y` - Only vertical movement possible\n\t * - `none` - No movement at all\n\t *\n\t * @default 'both'\n\t */\n\taxis?: DragAxis;\n\n\t/**\n\t * If true, uses `translate3d` instead of `translate` to move the element around, and the hardware acceleration kicks in.\n\t *\n\t * `true` by default, but can be set to `false` if [blurry text issue](https://developpaper.com/question/why-does-the-use-of-css3-translate3d-result-in-blurred-display/) occur\n\t *\n\t * @default true\n\t */\n\tgpuAcceleration?: boolean;\n\n\t/**\n\t * Applies `user-select: none` on `<body />` element when dragging,\n\t * to prevent the irritating effect where dragging doesn't happen and the text is selected.\n\t * Applied when dragging starts and removed when it stops.\n\t *\n\t * Can be disabled using this option\n\t *\n\t * @default true\n\t */\n\tapplyUserSelectHack?: boolean;\n\n\t/**\n\t * Ignores touch events with more than 1 touch.\n\t * This helps when you have multiple elements on a canvas where you want to implement\n\t * pinch-to-zoom behaviour.\n\t *\n\t * @default false\n\t *\n\t */\n\tignoreMultitouch?: boolean;\n\n\t/**\n\t * Disables dragging altogether.\n\t *\n\t * @default false\n\t */\n\tdisabled?: boolean;\n\n\t/**\n\t * Applies a grid on the page to which the element snaps to when dragging, rather than the default continuous grid.\n\t *\n\t * `Note`: If you're programmatically creating the grid, do not set it to [0, 0] ever, that will stop drag at all. Set it to `undefined`.\n\t *\n\t * @default undefined\n\t */\n\tgrid?: [number, number];\n\n\t/**\n\t * Control the position manually with your own state\n\t *\n\t * By default, the element will be draggable by mouse/finger, and all options will work as default while dragging.\n\t *\n\t * But changing the `position` option will also move the draggable around. These parameters are reactive,\n\t * so using Svelte's reactive variables as values for position will work like a charm.\n\t *\n\t *\n\t * Note: If you set `disabled: true`, you'll still be able to move the draggable through state variables. Only the user interactions won't work\n\t *\n\t */\n\tposition?: { x: number; y: number };\n\n\t/**\n\t * CSS Selector of an element inside the parent node(on which `use:draggable` is applied).\n\t *\n\t * If it is provided, Trying to drag inside the `cancel` selector will prevent dragging.\n\t *\n\t * @default undefined\n\t */\n\tcancel?: string | HTMLElement;\n\n\t/**\n\t * CSS Selector of an element inside the parent node(on which `use:draggable` is applied).\n\t *\n\t * If it is provided, Only clicking and dragging on this element will allow the parent to drag, anywhere else on the parent won't work.\n\t *\n\t * @default undefined\n\t */\n\thandle?: string | HTMLElement;\n\n\t/**\n\t * Class to apply on the element on which `use:draggable` is applied.\n\t * Note that if `handle` is provided, it will still apply class on the element to which this action is applied, **NOT** the handle\n\t *\n\t * neodrag'\n\t */\n\tdefaultClass?: string;\n\n\t/**\n\t * Class to apply on the element when it is dragging\n\t *\n\t * @default 'neodrag-dragging'\n\t */\n\tdefaultClassDragging?: string;\n\n\t/**\n\t * Class to apply on the element if it has been dragged at least once.\n\t *\n\t * @default 'neodrag-dragged'\n\t */\n\tdefaultClassDragged?: string;\n\n\t/**\n\t * Offsets your element to the position you specify in the very beginning.\n\t * `x` and `y` should be in pixels\n\t *\n\t */\n\tdefaultPosition?: { x: number; y: number };\n\n\t/**\n\t * Fires when dragging start\n\t */\n\tonDragStart?: (data: { offsetX: number; offsetY: number; domRect: DOMRect }) => void;\n\n\t/**\n\t * Fires when dragging is going on\n\t */\n\tonDrag?: (data: { offsetX: number; offsetY: number; domRect: DOMRect }) => void;\n\n\t/**\n\t * Fires when dragging ends\n\t */\n\tonDragEnd?: (data: { offsetX: number; offsetY: number; domRect: DOMRect }) => void;\n};\n\nconst enum DEFAULT_CLASS {\n\tMAIN = 'neodrag',\n\tDRAGGING = 'neodrag-dragging',\n\tDRAGGED = 'neodrag-dragged',\n}\n\nexport const draggable = (node: HTMLElement, options: DragOptions = {}) => {\n\tlet {\n\t\tbounds,\n\t\taxis = 'both',\n\t\tgpuAcceleration = true,\n\t\tapplyUserSelectHack = true,\n\t\tdisabled = false,\n\t\tignoreMultitouch = false,\n\n\t\tgrid,\n\n\t\tposition,\n\n\t\tcancel,\n\t\thandle,\n\n\t\tdefaultClass = DEFAULT_CLASS.MAIN,\n\t\tdefaultClassDragging = DEFAULT_CLASS.DRAGGING,\n\t\tdefaultClassDragged = DEFAULT_CLASS.DRAGGED,\n\n\t\tdefaultPosition = { x: 0, y: 0 },\n\n\t\tonDragStart,\n\t\tonDrag,\n\t\tonDragEnd,\n\t} = options;\n\n\tconst tick = new Promise(requestAnimationFrame);\n\n\tlet active = false;\n\n\tlet translateX = 0,\n\t\ttranslateY = 0;\n\n\tlet initialX = 0,\n\t\tinitialY = 0;\n\n\t// The offset of the client position relative to the node's top-left corner\n\tlet clientToNodeOffsetX = 0,\n\t\tclientToNodeOffsetY = 0;\n\n\tlet { x: xOffset, y: yOffset } = position\n\t\t? { x: position?.x ?? 0, y: position?.y ?? 0 }\n\t\t: defaultPosition;\n\n\tsetTranslate(xOffset, yOffset, node, gpuAcceleration);\n\n\tlet canMoveInX: boolean;\n\tlet canMoveInY: boolean;\n\n\tlet bodyOriginalUserSelectVal = '';\n\n\tlet computedBounds: DragBoundsCoords;\n\tlet nodeRect: DOMRect;\n\n\tlet dragEl: HTMLElement | undefined;\n\tlet cancelEl: HTMLElement | undefined;\n\n\tlet isControlled = !!position;\n\n\t// Arbitrary constants for better minification\n\tconst bodyStyle = document.body.style;\n\tconst nodeClassList = node.classList;\n\n\tconst getEventData = () => ({\n\t\toffsetX: translateX,\n\t\toffsetY: translateY,\n\t\tdomRect: node.getBoundingClientRect(),\n\t});\n\n\tconst callEvent = (eventName: 'neodrag:start' | 'neodrag' | 'neodrag:end', fn: typeof onDrag) => {\n\t\tconst data = getEventData();\n\t\tnode.dispatchEvent(new CustomEvent(eventName, { detail: data }));\n\t\tfn?.(data);\n\t};\n\n\tfunction fireSvelteDragStartEvent() {\n\t\tcallEvent('neodrag:start', onDragStart);\n\t}\n\n\tfunction fireSvelteDragEndEvent() {\n\t\tcallEvent('neodrag:end', onDragEnd);\n\t}\n\n\tfunction fireSvelteDragEvent() {\n\t\tcallEvent('neodrag', onDrag);\n\t}\n\n\tconst listen = addEventListener;\n\n\tlisten('touchstart', dragStart, false);\n\tlisten('touchend', dragEnd, false);\n\tlisten('touchmove', drag, false);\n\n\tlisten('mousedown', dragStart, false);\n\tlisten('mouseup', dragEnd, false);\n\tlisten('mousemove', drag, false);\n\n\t// On mobile, touch can become extremely janky without it\n\tnode.style.touchAction = 'none';\n\n\tconst calculateInverseScale = () => {\n\t\t// Calculate the current scale of the node\n\t\tlet inverseScale = node.offsetWidth / nodeRect.width;\n\t\tif (isNaN(inverseScale)) inverseScale = 1;\n\t\treturn inverseScale;\n\t};\n\n\tfunction dragStart(e: TouchEvent | MouseEvent) {\n\t\tif (disabled) return;\n\t\tif (ignoreMultitouch && e.type === 'touchstart' && (e as TouchEvent).touches.length > 1) return;\n\n\t\tnodeClassList.add(defaultClass);\n\n\t\tdragEl = getHandleEl(handle, node);\n\t\tcancelEl = getCancelElement(cancel, node);\n\n\t\tcanMoveInX = /(both|x)/.test(axis);\n\t\tcanMoveInY = /(both|y)/.test(axis);\n\n\t\t// Compute bounds\n\t\tif (typeof bounds !== 'undefined') {\n\t\t\tcomputedBounds = computeBoundRect(bounds, node);\n\t\t}\n\n\t\t// Compute current node's bounding client Rectangle\n\t\tnodeRect = node.getBoundingClientRect();\n\n\t\tif (isString(handle) && isString(cancel) && handle === cancel)\n\t\t\tthrow new Error(\"`handle` selector can't be same as `cancel` selector\");\n\n\t\tif (cancelEl?.contains(dragEl))\n\t\t\tthrow new Error(\n\t\t\t\t\"Element being dragged can't be a child of the element on which `cancel` is applied\"\n\t\t\t);\n\n\t\tif (dragEl.contains(<HTMLElement>e.target) && !cancelEl?.contains(<HTMLElement>e.target))\n\t\t\tactive = true;\n\n\t\tif (!active) return;\n\n\t\tif (applyUserSelectHack) {\n\t\t\t// Apply user-select: none on body to prevent misbehavior\n\t\t\tbodyOriginalUserSelectVal = bodyStyle.userSelect;\n\t\t\tbodyStyle.userSelect = 'none';\n\t\t}\n\n\t\t// Dispatch custom event\n\t\tfireSvelteDragStartEvent();\n\n\t\tconst { clientX, clientY } = isTouchEvent(e) ? e.touches[0] : e;\n\t\tconst inverseScale = calculateInverseScale();\n\n\t\tif (canMoveInX) initialX = clientX - xOffset / inverseScale;\n\t\tif (canMoveInY) initialY = clientY - yOffset / inverseScale;\n\n\t\t// Only the bounds uses these properties at the moment,\n\t\t// may open up in the future if others need it\n\t\tif (computedBounds) {\n\t\t\tclientToNodeOffsetX = clientX - nodeRect.left;\n\t\t\tclientToNodeOffsetY = clientY - nodeRect.top;\n\t\t}\n\t}\n\n\tfunction dragEnd() {\n\t\tif (!active) return;\n\n\t\t// Apply class defaultClassDragged\n\t\tnodeClassList.remove(defaultClassDragging);\n\t\tnodeClassList.add(defaultClassDragged);\n\n\t\tif (applyUserSelectHack) bodyStyle.userSelect = bodyOriginalUserSelectVal;\n\n\t\tfireSvelteDragEndEvent();\n\n\t\tif (canMoveInX) initialX = translateX;\n\t\tif (canMoveInX) initialY = translateY;\n\n\t\tactive = false;\n\t}\n\n\tfunction drag(e: TouchEvent | MouseEvent) {\n\t\tif (!active) return;\n\n\t\t// Apply class defaultClassDragging\n\t\tnodeClassList.add(defaultClassDragging);\n\n\t\te.preventDefault();\n\n\t\tnodeRect = node.getBoundingClientRect();\n\n\t\tconst { clientX, clientY } = isTouchEvent(e) ? e.touches[0] : e;\n\n\t\t// Get final values for clamping\n\t\tlet finalX = clientX,\n\t\t\tfinalY = clientY;\n\n\t\tconst inverseScale = calculateInverseScale();\n\n\t\tif (computedBounds) {\n\t\t\t// Client position is limited to this virtual boundary to prevent node going out of bounds\n\t\t\tconst virtualClientBounds: DragBoundsCoords = {\n\t\t\t\tleft: computedBounds.left + clientToNodeOffsetX,\n\t\t\t\ttop: computedBounds.top + clientToNodeOffsetY,\n\t\t\t\tright: computedBounds.right + clientToNodeOffsetX - nodeRect.width,\n\t\t\t\tbottom: computedBounds.bottom + clientToNodeOffsetY - nodeRect.height,\n\t\t\t};\n\n\t\t\tfinalX = clamp(finalX, virtualClientBounds.left, virtualClientBounds.right);\n\t\t\tfinalY = clamp(finalY, virtualClientBounds.top, virtualClientBounds.bottom);\n\t\t}\n\n\t\tif (Array.isArray(grid)) {\n\t\t\tlet [xSnap, ySnap] = grid;\n\n\t\t\tif (isNaN(+xSnap) || xSnap < 0)\n\t\t\t\tthrow new Error('1st argument of `grid` must be a valid positive number');\n\n\t\t\tif (isNaN(+ySnap) || ySnap < 0)\n\t\t\t\tthrow new Error('2nd argument of `grid` must be a valid positive number');\n\n\t\t\tlet deltaX = finalX - initialX,\n\t\t\t\tdeltaY = finalY - initialY;\n\n\t\t\t[deltaX, deltaY] = snapToGrid(\n\t\t\t\t[Math.floor(xSnap / inverseScale), Math.floor(ySnap / inverseScale)],\n\t\t\t\tdeltaX,\n\t\t\t\tdeltaY\n\t\t\t);\n\n\t\t\tfinalX = initialX + deltaX;\n\t\t\tfinalY = initialY + deltaY;\n\t\t}\n\n\t\tif (canMoveInX) translateX = (finalX - initialX) * inverseScale;\n\t\tif (canMoveInY) translateY = (finalY - initialY) * inverseScale;\n\n\t\txOffset = translateX;\n\t\tyOffset = translateY;\n\n\t\tfireSvelteDragEvent();\n\n\t\ttick.then(() => setTranslate(translateX, translateY, node, gpuAcceleration));\n\t\t// Promise.resolve().then(() => setTranslate(translateX, translateY, node, gpuAcceleration));\n\t}\n\n\treturn {\n\t\tdestroy: () => {\n\t\t\tconst unlisten = removeEventListener;\n\n\t\t\tunlisten('touchstart', dragStart, false);\n\t\t\tunlisten('touchend', dragEnd, false);\n\t\t\tunlisten('touchmove', drag, false);\n\n\t\t\tunlisten('mousedown', dragStart, false);\n\t\t\tunlisten('mouseup', dragEnd, false);\n\t\t\tunlisten('mousemove', drag, false);\n\t\t},\n\t\tupdate: (options: DragOptions) => {\n\t\t\t// Update all the values that need to be changed\n\t\t\taxis = options.axis || 'both';\n\t\t\tdisabled = options.disabled ?? false;\n\t\t\tignoreMultitouch = options.ignoreMultitouch ?? false;\n\t\t\thandle = options.handle;\n\t\t\tbounds = options.bounds;\n\t\t\tcancel = options.cancel;\n\t\t\tapplyUserSelectHack = options.applyUserSelectHack ?? true;\n\t\t\tgrid = options.grid;\n\t\t\tgpuAcceleration = options.gpuAcceleration ?? true;\n\n\t\t\tconst dragged = nodeClassList.contains(defaultClassDragged);\n\n\t\t\tnodeClassList.remove(defaultClass, defaultClassDragged);\n\n\t\t\tdefaultClass = options.defaultClass ?? DEFAULT_CLASS.MAIN;\n\t\t\tdefaultClassDragging = options.defaultClassDragging ?? DEFAULT_CLASS.DRAGGING;\n\t\t\tdefaultClassDragged = options.defaultClassDragged ?? DEFAULT_CLASS.DRAGGED;\n\n\t\t\tnodeClassList.add(defaultClass);\n\n\t\t\tif (dragged) nodeClassList.add(defaultClassDragged);\n\n\t\t\tif (isControlled) {\n\t\t\t\txOffset = translateX = options.position?.x ?? translateX;\n\t\t\t\tyOffset = translateY = options.position?.y ?? translateY;\n\n\t\t\t\ttick.then(() => setTranslate(translateX, translateY, node, gpuAcceleration));\n\t\t\t}\n\t\t},\n\t};\n};\n\nconst isTouchEvent = (event: MouseEvent | TouchEvent): event is TouchEvent =>\n\t!!(event as TouchEvent).touches?.length;\n\nconst clamp = (val: number, min: number, max: number) => Math.min(Math.max(val, min), max);\n\nconst isString = (val: unknown): val is string => typeof val === 'string';\n\nconst snapToGrid = memoize(\n\t([xSnap, ySnap]: [number, number], pendingX: number, pendingY: number): [number, number] => {\n\t\tconst calc = (val: number, snap: number) => Math.round(val / snap) * snap;\n\n\t\tconst x = calc(pendingX, xSnap);\n\t\tconst y = calc(pendingY, ySnap);\n\n\t\treturn [x, y];\n\t}\n);\n\nfunction getHandleEl(handle: DragOptions['handle'], node: HTMLElement) {\n\tif (!handle) return node;\n\n\tif (handle instanceof HTMLElement) return handle;\n\n\t// Valid!! Let's check if this selector exists or not\n\tconst handleEl = node.querySelector<HTMLElement>(handle);\n\tif (handleEl === null)\n\t\tthrow new Error(\n\t\t\t'Selector passed for `handle` option should be child of the element on which the action is applied'\n\t\t);\n\n\treturn handleEl!;\n}\n\nfunction getCancelElement(cancel: DragOptions['cancel'], node: HTMLElement) {\n\tif (!cancel) return;\n\n\tif (cancel instanceof HTMLElement) return cancel;\n\n\tconst cancelEl = node.querySelector<HTMLElement>(cancel);\n\n\tif (cancelEl === null)\n\t\tthrow new Error(\n\t\t\t'Selector passed for `cancel` option should be child of the element on which the action is applied'\n\t\t);\n\n\treturn cancelEl;\n}\n\nfunction computeBoundRect(bounds: DragOptions['bounds'], rootNode: HTMLElement) {\n\tif (bounds instanceof HTMLElement) return bounds.getBoundingClientRect();\n\n\tif (typeof bounds === 'object') {\n\t\t// we have the left right etc\n\n\t\tconst { top = 0, left = 0, right = 0, bottom = 0 } = bounds;\n\n\t\tconst computedRight = window.innerWidth - right;\n\t\tconst computedBottom = window.innerHeight - bottom;\n\n\t\treturn { top, right: computedRight, bottom: computedBottom, left };\n\t}\n\n\t// It's a string\n\tif (bounds === 'parent') return (<HTMLElement>rootNode.parentNode).getBoundingClientRect();\n\n\tconst node = document.querySelector<HTMLElement>(<string>bounds);\n\tif (node === null)\n\t\tthrow new Error(\"The selector provided for bound doesn't exists in the document.\");\n\n\tconst computedBounds = node.getBoundingClientRect();\n\treturn computedBounds;\n}\n\nfunction setTranslate(xPos: number, yPos: number, el: HTMLElement, gpuAcceleration: boolean) {\n\tel.style.transform = gpuAcceleration\n\t\t? `translate3d(${+xPos}px, ${+yPos}px, 0)`\n\t\t: `translate(${+xPos}px, ${+yPos}px)`;\n}\n"],"names":["monadic","fn","cache","serializer","arg","value","cacheKey","computedValue","get","call","this","set","variadic","args","Array","prototype","slice","arguments","apply","strategyDefault","options","context","strategy","serialize","bind","assemble","length","create","serializerDefault","JSON","stringify","ObjectWithoutPrototypeCache","Object","has","key","cacheDefault","draggable","node","bounds","axis","gpuAcceleration","applyUserSelectHack","disabled","ignoreMultitouch","grid","position","cancel","handle","defaultClass","defaultClassDragging","defaultClassDragged","defaultPosition","x","y","onDragStart","onDrag","onDragEnd","tick","Promise","requestAnimationFrame","canMoveInX","canMoveInY","active","translateX","translateY","initialX","initialY","clientToNodeOffsetX","clientToNodeOffsetY","xOffset","yOffset","setTranslate","computedBounds","nodeRect","dragEl","cancelEl","bodyOriginalUserSelectVal","isControlled","bodyStyle","document","body","style","nodeClassList","classList","callEvent","eventName","data","offsetX","offsetY","domRect","getBoundingClientRect","dispatchEvent","CustomEvent","detail","listen","addEventListener","dragStart","dragEnd","drag","touchAction","calculateInverseScale","inverseScale","offsetWidth","width","isNaN","e","type","touches","add","HTMLElement","handleEl","querySelector","Error","getHandleEl","getCancelElement","test","rootNode","top","left","right","bottom","window","innerWidth","innerHeight","parentNode","computeBoundRect","isString","contains","target","userSelect","clientX","clientY","isTouchEvent","remove","preventDefault","finalX","finalY","virtualClientBounds","height","clamp","isArray","xSnap","ySnap","deltaX","deltaY","snapToGrid","Math","floor","then","destroy","unlisten","removeEventListener","update","options2","dragged","event","val","min","max","pendingX","pendingY","calc","snap","round","xPos","yPos","el","transform"],"mappings":"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"}